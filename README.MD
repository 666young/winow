## WINOW is not OneScript.web

Минималистичный веб-сервер, построен на нативном TCPСервер, и работает на желудях. 

Зачем это нужно, когда есть OneScript.Web, -CGI и т.д. Отвечаю, для того что бы все было на чистом OneScript! Потому, что могу. С полным контролем, от входа двоичных данных на порт, до определия маршрута, получения данных, генерацией ответа по шаблону и отправкой обратно клиенту.

## Есть вопросы и пожелания ?

Можно оставить тут https://github.com/Nivanchenko/winow/issues

## Что можно сделать ?

Данная библиотека позволит Вам достаточно просто подготовить и запустить:

- микросервис, с гибким API
- быстро сделать МОК для вашего "любимого" удаленного API и наконец-то продолжить комфортно разработку.
- Веб приложение, с отдачей статичных файлов, и генерацией страниц по шаблонам.
- И все, на что хватит фантазии.

## Какие возможности ?

В данной библиотеке я постарался реализовать подход в разработке приложений в стиле MVC. 

На текущий момент winow позволяет:

- Обрабатывать входящие GET и POST запросы.
- Обеспечивать маршрутизацию входящего запроса до нужного метода.
- Разбирать все входящие параметры.
- Обрабатывать тело входящего POST запроса.
- Работать с печеньками (Cookie). 
- Работать с сессиями.
- Отдавать статичные файлы(картинки, архивы и т.д.)
- Работать с шаблонами ответов (Синтаксис шаблона чем-то похож на jinja2, но сильно упращен).

## Ограничения ?

Да ! Нет никаких обещаний на тему вывоза больших нагрузок. И нет поддержки https, погружаться в историю с шифрованием трафика, я еще не готов.

## Как, из чего, зависимости ?

Библиотека разработана с использованием фрейворка для инверсии зависимостей - https://github.com/nixel2007/autumn. Для более эффективной работы с winow, следует ознакомиться. А так же обязательно пройти по ссылке и поставить звездочку, без этого ничего работать не будет.

## Хеллоу ворлд !

От слов к делу, что бы понять как это все работает, давайте сделаем hello-world приложение, которое будет запускаться на localhost:3331 и отвечать простым текстом hello-world. 

Первым делом, ну нужна точка входа, которая запустит приложение. 

Создадим такой файл:
```
ПриветМир.os
```

```bsl
#Использовать winow

// Создадим сервер, который будет ядром мироздания.
Сервер = ФабрикаСерверов.СоздатьСервер();	

//Установим желаемый порт
Сервер.Настройки.Порт = 3331;

// В целях удобства разработки и отладки, отключим обработку запросов в ФЗ
Сервер.Настройки.ЗапросВФоновыхЗаданиях = Ложь;

// Для того, что бы дать сервер знал, как обрабатывать входящие запросы, в него нужно такой фунционал загрузить. Можно это сделать вот такой командой из каталога.
// Первый параметр, произвольное имя, второй каталог, в котором находятся классы, для управления логикой обработки запросов.
КонтекстПриложения = Сервер.МенеджерПриложений.ДобавитьПриложениеИзКаталога("ПриветМир", "./hwapp");

// Запуск сервера
Сервер.Старт();
```

Теперь можете запустить файл ```ПриветМир.os``` и ничего не будет работать. И причин на это ровно две. Первая вы не сходили https://github.com/nixel2007/autumn и не поставили звезду. Вторая мы не создали каталог, с классами, которые обрабатывают логику запросов. Я верю что вы успели сходить и поставить зведу, перейдем к созданию логики.

Создаем каталог и файл:

```
hwapp/КонтролПриветствия.os
```

```bsl
&Пластилин
Перем ОбщийКонтейнер Экспорт;

&Контроллер("/")
&Желудь
Процедура ПриСозданииОбъекта()

КонецПроцедуры

&ТочкаМаршрута("/")
Процедура Приветствие(ВходящийЗапрос, Ответ, Сессия) Экспорт

	Ответ.УстановитьТипКонтента("html");

	Ответ.ТелоТекст = СтрШаблон("<!DOCTYPE html>
								|<div> %1 </div>",  "Привет новый дивный мир !");

КонецПроцедуры
```

И снова пробуем запустить ```ПриветМир.os```, и идем в http://localhost:3331/

И чудо свершилось:

![hw1](docs/hw1.png)

## Передача параметров в строке запроса.

После продолжительного восторга, двигаемся дальше, и на новом примере разберем, по частям, как это работает.

Давайте сделаем еще один контрол, еще более интерактивный. Сделаем так, что приложение будет нас встречать по имени. Имя наше мы хотим передавать в параметрах строки запроса.

http://localhost:3331/greeter/getparams?name=Nikita&familia=ivanchenko

Где ```greeter``` путь до нашего контрола. И ```getparams``` точка входа для метода, который обрабатывает запрос. Все что полсе ```?``` именные параметры.

Поехали, создаем файл:

```
hwapp/ИнтерактивныйКонтролПриветствия.os
```

```bsl
&Пластилин
Перем ОбщийКонтейнер Экспорт;

&Контроллер("/greeter")
&Желудь
Процедура ПриСозданииОбъекта()

КонецПроцедуры

&ТочкаМаршрута("getparams")
Процедура Приветствие(ВходящийЗапрос, Ответ, Сессия) Экспорт

	Ответ.УстановитьТипКонтента("html");

	Имя = ВходящийЗапрос.ПараметрыИменные["name"];
	Фамилия = ВходящийЗапрос.ПараметрыИменные["familia"];

	Ответ.ТелоТекст = СтрШаблон("<!DOCTYPE html>
								|<div> Имя: %1 </div>
								|<div> Фамилия: %2 </div>",  Имя, Фамилия);

КонецПроцедуры
```

Опять запускаем ```ПриветМир.os```, и идем теперь вот так http://localhost:3331/greeter/getparams?name=Никита&familia=Иванченко

![hw2](docs/hw2.png)

Снова полный успех! Но давайте по подробней остановимся на каждом этапе этого чуда.

Файл, который мы только что сделали, описывает определенную точку в адресной строке. При совпадении с которой, перехватывается управление над входячим запросом. Разберем этот файл подробнее.

Сначала описывается реквизит нашего класса

```bsl
&Пластилин
Перем ОбщийКонтейнер Экспорт;
```

Аннотация ```&Пластилин``` перед объявлением переменной говорит о том, что когда будет создан наш объект-контрол, под капотом случится натуральная магия, и в эту переменную будет установлен некий объект. Предназначение которого, мы разберем далее.

```bsl
&Контроллер("/greeter")
&Желудь
Процедура ПриСозданииОбъекта()

КонецПроцедуры
``` 

Следом идет конструктор нашего класса, ```ПриСозданииОбъекта()```. Весь код, который в нем написан, будет выполнен при создании. Удобно тут выполнять всякую инициализацию переменных например. 

Этот метод имеет две аннотации ```&Желудь```, сейчас она не интересна. О ней можно почитать по ссылкам, которые я давал выше. И ```&Контроллер("/greeter")``` говорит о том, что наш контроллер перехватит управление, всего что будет в адресе запроса http://localhost:3331/greeter и после.

Стоит отметить что аннотация может быть более длинной, что бы отвечать логике описания api. Например вот так ```&Контроллер("/app/api/v1/greeter")``` тоже рабочий вариант, только ходить нужно уже вот сюда http://localhost:3331/app/api/v1/greeter

У любого контрола может быть любое множество методов, которыми он обрабатывает входящий запрос.

```bsl
&ТочкаМаршрута("getparams")
Процедура Приветствие(ВходящийЗапрос, Ответ, Сессия) Экспорт
``` 

Для того, что бы процедура контролла могла понимать, что ее вызывают из запроса, ее нужно пометить аннотацией ```&ТочкаМаршрута("getparams")```. Где параметр аннотации указывает имя в пути, после которого ей нужно сработать.

Так же, что все сработало, процедура должна отвечать нескольким требованиям:

- Быть экспортной
- Принимать на вход три параметра ```ВходящийЗапрос, Ответ, Сессия```. Назначение которых мы разберем по ходу дела.

```ВходящийЗапрос``` Например хранит всю информацию, которая пришла к нам от клиента. В том чиле ```ВходящийЗапрос.ПараметрыИменные``` соответствие, хранящее значения всех параметров, которые переданы после знака ```?```

Дальше мы лихо эти параметры читаем.

```bsl
Имя = ВходящийЗапрос.ПараметрыИменные["name"];
Фамилия = ВходящийЗапрос.ПараметрыИменные["familia"];
``` 

Следующий параметр ```Ответ```, в котором собирается все, что будет отправлено обратно клиенту. Например вот так

```bsl
Ответ.УстановитьТипКонтента("html");
``` 

Устанавливается заголовок ```Content-Type```, благодаря которому браузер понимает, как отобразить то, что мы ему шлем.

По умолчанию поддерживаются типы:

```bsl
ОписанияТиповРасширений = Новый Соответствие();
ОписанияТиповРасширений.Вставить("htm","text/html; charset=utf-8");
ОписанияТиповРасширений.Вставить("html","text/html; charset=utf-8");
ОписанияТиповРасширений.Вставить("css","text/css");
ОписанияТиповРасширений.Вставить("js","text/javascript");
ОписанияТиповРасширений.Вставить("jpg","image/jpeg");
ОписанияТиповРасширений.Вставить("jpeg","image/jpeg");
ОписанияТиповРасширений.Вставить("png","image/png");
ОписанияТиповРасширений.Вставить("gif","image/gif");
ОписанияТиповРасширений.Вставить("ico","image/x-icon");
ОписанияТиповРасширений.Вставить("zip","application/x-compressed");
ОписанияТиповРасширений.Вставить("rar","application/x-compressed");
ОписанияТиповРасширений.Вставить("json","application/json");
ОписанияТиповРасширений.Вставить("txt","text/plain; charset=utf-8");
``` 

Ну и конечно же устанавливаем текст ответа, который вернется клиенту. 

```bsl
Ответ.ТелоТекст = СтрШаблон("<!DOCTYPE html>
                            |<div> Имя: %1 </div>
                            |<div> Фамилия: %2 </div>",  Имя, Фамилия);
``` 

Сейчас это не удобно и не красиво. Но к концу нашей беседы мы разберемся как сделать красиво.

## Еще один способ передачи параметров в строке запроса. 

Предыдущий пример показал, как можно передать параметры в строке запроса, при этом параметры имели имена. Теперь рассморим пример, когда параметры упорядоченные.

Давайте сделаем наконец калькулятор! И будет он работать вот так:

```
http://localhost:3331/greeter/calc/<operation>/<first>/<second>/
```
Где ```calc``` - точка маршрута. ```operation``` - вид операции, будем поддерживать minus и plus. и следом два слогаемых нашего уравнения.

Добавим в наш

```
hwapp/ИнтерактивныйКонтролПриветствия.os
```

новую точку маршрута:

```bsl
&ТочкаМаршрута("calc")
Процедура Калькулятор(ВходящийЗапрос, Ответ, Сессия) Экспорт

	Ответ.УстановитьТипКонтента("html");

	Если ВходящийЗапрос.ПараметрыПорядковые.Количество() <> 3 Тогда

		Решение = "Неверное число параметров";

	ИначеЕсли Не (ВходящийЗапрос.ПараметрыПорядковые[0] = "minus" 
				ИЛИ	ВходящийЗапрос.ПараметрыПорядковые[0] = "plus") Тогда
		Решение = "Операция не распознана";

	Иначе
		Попытка
			Число1 = Число(ВходящийЗапрос.ПараметрыПорядковые[1]);
			Число2 = Число(ВходящийЗапрос.ПараметрыПорядковые[2]);

			Если ВходящийЗапрос.ПараметрыПорядковые[0] = "minus" Тогда
				Решение = Число1 - Число2;
			Иначе
				Решение = Число1 + Число2;
			КонецЕсли

		Исключение
			Решение = "Ошибка конвертации в число"
		КонецПопытки;
	КонецЕсли;

	Ответ.ТелоТекст = СтрШаблон("<!DOCTYPE html>
								|<div> Ответ: %1 </div>",  Решение);

КонецПроцедуры
``` 

Перезапустим приложение, и перейдем по ссылке http://localhost:3331/greeter/calc/plus/3/2

И в ответ перед нами будет красоваться 

![hw3](docs/hw3.png)

На самом деле, тут все очень просто. Когда мы объявляем точку маршрута ```&ТочкаМаршрута("calc")```, все что дальше в пути через ```/``` будет любезно складываться в массив ```ВходящийЗапрос.ПараметрыПорядковые```. А что делать с массивами, вы и без меня знаете.

## Входящие POST запросы

С пост запросами, все почти так же просто. ```ВходящийЗапрос``` Имеет два поля ```Тело``` и ```ТелоДвоичныеДанные```, т.к. пользователь может закинуть нам как текст, так и картинку например. 

Давайте потренируемся в обработке таких запросов, усовершенствуем наше приложение и научим его возводить в степень переданое число. 

Вводить число мы будем по адресу http://localhost:3331/greeter/inputstepen, где будет форма ввода числа, и кнопка расчета. После расчета мы будем перенаправлены на http://localhost:3331/greeter/resultstepen. Форма будет передавать параметры методом POST.

Для реализации этой задумки добавим в наш

```
hwapp/ИнтерактивныйКонтролПриветствия.os
```

этот код, с двумя новыми точками маршрута

```bsl
&ТочкаМаршрута("inputstepen")
Процедура ВводСтепени(ВходящийЗапрос, Ответ, Сессия) Экспорт

	Ответ.УстановитьТипКонтента("html");

	Ответ.ТелоТекст = 
	"<form method=""post"" action=""/greeter/resultstepen"">
	|<label for=""chislo"">Введи число:</label><br>
	|<input type=""text"" id=""chislo"" name=""chislo""><br>
	|<label for=""stepen"">Введи степень:</label><br>
	|<input type=""text"" id=""stepen"" name=""stepen""><br><br>
	|<input type=""submit"" value=""Посчитать"">
	|</form> ";

КонецПроцедуры

&ТочкаМаршрута("resultstepen")
Процедура ВозводительВСтепень(ВходящийЗапрос, Ответ, Сессия) Экспорт

	Ответ.УстановитьТипКонтента("html");

	ПостПараметры = ОбщийКонтейнер.Парсеры.ПараметрыИзТекста(ВходящийЗапрос.Тело);

	Попытка
		Решение = Pow(ПостПараметры["chislo"], ПостПараметры["stepen"]);	
	Исключение
		Решение = "Ошибка при расчетах " + ОписаниеОшибки();
	КонецПопытки;

	Ответ.ТелоТекст = СтрШаблон("<!DOCTYPE html>
								|<div> Ответ: %1 </div>",  Решение);

КонецПроцедуры
``` 

![hw4](docs/hw4.png)

![hw5](docs/hw5.png)

Теперь разберемся, что тут произошло. Не буду останавливаться на описании HTML тегов, для этого в интернете сайтов больше чем звезд на небе. 

Точка маршрута ```inputstepen``` показала нам форму, которая при расчете перенаправляет нас на ```resultstepen``` и в теле запроса передает параметры формы, которые имеют вид ```chislo=2&stepen=3```. Все что нам осталось, это обработать запрос.

Мы можем парсить самостоятельно, но объект ```ОбщийКонтейнер```, который мы внедрили ранее, имеет объект, который умеет парсить параметры в таком формате ```Парсеры.ПараметрыИзТекста(<СтрокаСПараметрами>)```. Этот метод вернет соответсвие со значениями, которые в последствии нужно правельно использовать.

## Работа с куками

Куки, это возможно сохранить на клиенте, в браузере, какую-либо информацию. Объекты ```ВходящийЗапрос``` и ```Ответ```, которые мы получаем в метод, который мы помечаем как ```ТочкаМаршрута```. Оба этих объекта имеют свойство ```Куки```. Соответственно во входящем запросе их можно читать, а в ответе устанавливать.

Модернизируем файл

```
hwapp/ИнтерактивныйКонтролПриветствия.os
```

```bsl
&ТочкаМаршрута("setcookie")
Процедура УстановитьКуку(ВходящийЗапрос, Ответ, Сессия) Экспорт

	Ответ.УстановитьТипКонтента("html");

	ИмяКуки = "ДатаПоследнегоВхода";
	ЗначениеКуки = ТекущаяДата();

	НоваяКука = Ответ.Куки.Добавить(ИмяКуки, ЗначениеКуки);

	Ответ.ТелоТекст = "<!DOCTYPE html>
						|<div> Кука установлена </div>";

КонецПроцедуры

&ТочкаМаршрута("readcookie")
Процедура ПрочитатьКуку(ВходящийЗапрос, Ответ, Сессия) Экспорт

	Ответ.УстановитьТипКонтента("html");

	ИмяКуки = "ДатаПоследнегоВхода";

	ЗначениеКуки = ВходящийЗапрос.Куки.ПолучитьЗначениеПоИмени(ИмяКуки);

	Ответ.ТелоТекст = СтрШаблон("<!DOCTYPE html>
								|<div> Кука: %1 </div>", ЗначениеКуки);

КонецПроцедуры
``` 

![hw6](docs/hw6.png)

![hw7](docs/hw7.png)

Еще раз, не забываем, что куки хранятся на стороне браузера.

## Хранение данных сессии

Третий параметр точки маршрута ```Сессия``` имеет поле ```Данные```. По сути, это соответствие, в которое можно записывать и читать любые значения. Эти данные хранятся на сервере, пока он работет. При остановке, денные сессии пропадают. При необходимости, в рамках приложения, можно дописать хранение данных сессии в файлах, базах данных и тд.

Еще один пример

```
hwapp/ИнтерактивныйКонтролПриветствия.os
```

```bsl
&ТочкаМаршрута("setsessiondata")
Процедура УстановитьДанныеСессии(ВходящийЗапрос, Ответ, Сессия) Экспорт

	Ответ.УстановитьТипКонтента("html");

	ИмяПараметраСессии = "ДатаПоследнегоВхода";
	ЗначениеПараметраСессии  = ТекущаяДата();

	
	Сессия.Данные[ИмяПараметраСессии] = ЗначениеПараметраСессии;

	Ответ.ТелоТекст = "<!DOCTYPE html>
						|<div> Данные сессии установлены </div>";

КонецПроцедуры

&ТочкаМаршрута("readsessiondata")
Процедура ПрочитатьДанныеСессии(ВходящийЗапрос, Ответ, Сессия) Экспорт

	Ответ.УстановитьТипКонтента("html");

	ИмяПараметраСессии = "ДатаПоследнегоВхода";
	ЗначениеПараметраСессии  = Сессия.Данные[ИмяПараметраСессии];

	Ответ.ТелоТекст = СтрШаблон("<!DOCTYPE html>
								|<div> Значение параметра сессии: %1 </div>", ЗначениеПараметраСессии);

КонецПроцедуры
``` 

![hw8](docs/hw8.png)

![hw9](docs/hw9.png)

## Публикация статичных файлов.

Часто нужно открывать доступ для скачивания всевозможных файлов. Таких как картинки, js-скрипты, css и т.д.

Для этого у менеджера приложений есть специальный метод ```Сервер.МенеджерПриложений.ДобавитьКаталогСтатичныхФайлов(<Каталог на диске>, <Путь на сайте>);```

Давайте попробуем сделать наше приложение повеселее и добавить картинок.

Добавим в каталог приложения пару картинок.

```
hwapp/files/zl1.jpg
hwapp/files/fun/zl2.jpg
```

Подключим этот каталог с файлами

```
ПриветМир.os
```

```bsl
#Использовать winow

Сервер = ФабрикаСерверов.СоздатьСервер();	

Сервер.Настройки.Порт = 3331;

Сервер.Настройки.ЗапросВФоновыхЗаданиях = Ложь;

КонтекстПриложения = Сервер.МенеджерПриложений.ДобавитьПриложениеИзКаталога("ПриветМир", "./hwapp");

// Добавляем каталог, так что бы файлы были доступны по пути /images
Сервер.МенеджерПриложений.ДобавитьКаталогСтатичныхФайлов("./hwapp/files", "/images");

Сервер.Старт();
```

Данный метод можно вызвать несколько раз, и примонтировать разные физические каталоги, в разные места приложения.

```bsl
Сервер.МенеджерПриложений.ДобавитьКаталогСтатичныхФайлов("./hwapp/catsfoto", "/kotiki");
Сервер.МенеджерПриложений.ДобавитьКаталогСтатичныхФайлов("./hwapp/dogsfoto", "/sobachki");
``` 

![hw10](docs/hw10.png)

Как видим, по нужному пути теперь доступны файлы из каталога, при чем с сохранением внутренней иерархии каталога файлов.

Стоит отметить, что доступны становяться не все файлы сразу, а только те, расширения которых описаны в соотвествии

```bsl
ОписанияТиповРасширений = Новый Соответствие();
ОписанияТиповРасширений.Вставить("htm","text/html; charset=utf-8");
ОписанияТиповРасширений.Вставить("html","text/html; charset=utf-8");
ОписанияТиповРасширений.Вставить("css","text/css");
ОписанияТиповРасширений.Вставить("js","text/javascript");
ОписанияТиповРасширений.Вставить("jpg","image/jpeg");
ОписанияТиповРасширений.Вставить("jpeg","image/jpeg");
ОписанияТиповРасширений.Вставить("png","image/png");
ОписанияТиповРасширений.Вставить("gif","image/gif");
ОписанияТиповРасширений.Вставить("ico","image/x-icon");
ОписанияТиповРасширений.Вставить("zip","application/x-compressed");
ОписанияТиповРасширений.Вставить("rar","application/x-compressed");
ОписанияТиповРасширений.Вставить("json","application/json");
ОписанияТиповРасширений.Вставить("txt","text/plain; charset=utf-8");
``` 

При желании этот список можно расширить.


